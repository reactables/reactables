
# Reactable Forms API

## `FormBuilders` <a name="api-builders"></a>

Reactable form builders are inspired by [Angular Reactive Forms](https://angular.dev/guide/forms).  
Forms are built by composing configuration objects using the helper functions: `control`, `group`, and `array`.  
Once composed, you initialize a form with the `build` function.  

---

### `build` <a name="api-build"></a>

`build` is a factory function for creating a **Form Reactable** from a configuration object generated by `control`, `group`, or `array`.  
You can also provide an optional `RxFormOptions` object to customize behavior.

#### Example

```typescript
import { build, control, group, array, load } from "reactables";

// Simple form with a single control 
const rxSimpleForm = build(control(["John Doe"]));

// Form with array of controls
const rxEmailsForm = build(
  array({
    controls: [
      control(["john@example.com"]),
      control(["doe@example.com"]),
    ],
  })
);

// Form with nested group 
const rxProfileForm = build(
  group({
    controls: {
      firstName: control(["John"]),
      lastName: control(["Doe"]),
    },
  })
);

// Subscribe to the profile form
const [state$, actions, actions$] = rxProfileForm;

state$.subscribe(formState => console.log("Profile form state:", formState));
actions.updateValues({ controlRef: ["firstName"] , value: "Jane", });

```

### `control` <a name="api-control"></a>

Creates a **form control configuration** object for a single field.  
You can initialize it either with a configuration object or with a **short-form tuple** for convenience.

#### Example

```typescript
// Using short-form tuple
const firstNameControl = control(["John", ['required']]);

// Using object notation with validators
const ageControl = control({
  initialValue: 30,
  validators: ["required", "number"],
  normalizer: ["numbersOnly"]
});

```
Note: Validators are specified as strings here, but the actual functions must be provided via form options when initializing the form.

### `group` <a name="api-group"></a>

Creates a **form group configuration** object, which is a collection of controls, nested groups, or arrays.  
The `controls` dictionary contains keys for each child control.  

You can also define **validators and async validators** at the group level, which apply to the group as a whole.

#### Example

```typescript
const profileGroup = group({
  controls: {
    firstName: control(["John", ["required"]]),
    lastName: control(["Doe"]),
    age: control([30, ["required", "number"]]),
  },
  validators: ["groupValidator"],
  asyncValidators: ["asyncGroupValidator"]
});

```

Note: Validators are specified as strings in the configuration; the actual functions must be provided via form options when initializing the form.

### `array` <a name="api-array"></a>

Creates a **form array configuration**, which is a list of controls, groups, or arrays.
Arrays are useful for repeated fields, such as multiple email addresses or phone numbers.

You can also define **validators and async validators** at the array level, which apply to the array as a whole.

#### Example

```typescript
const emailsArray = array({
  controls: [
    control(["john@example.com", ["required"]]),
    control(["doe@example.com"]),
  ],
  validators: ["arrayValidator"],
  asyncValidators: ["asyncArrayValidator"]
});

```

Note: Validators are specified as strings in the configuration; the actual functions must be provided via form options when initializing the form.

### `load` <a name="api-load"></a>

`load` creates a Reactable form from a **previously saved form state**, allowing you to restore a form with existing values.  
You can provide optional form options to customize behavior when loading.

#### Example

```typescript
import { load } from "reactables";

// Load a saved form state from session storage
const savedState = JSON.parse(sessionStorage.getItem("profileForm") || "{}");
const rxLoadedForm = load(savedState);

const [state$, actions] = rxLoadedForm;

state$.subscribe(formState => console.log("Restored form state:", formState));

```

### `RxFormOptions` <a name="api-form-options"></a>

Options for customizing the behavior of a Reactable form.  
You can provide additional action sources, custom reducers, validators, and other settings.

| Option     | Description |
|-----------|-------------|
| **reducers** | Dictionary of custom reducers for implementing special form behavior. Use built-in `FormReducers` to safely update form state while maintaining parent/child validation integrity. |
| **sources** | Additional action Observables the form should listen to. Can be an array or a dictionary mapping action type to observable payload. |
| **providers** | See [`RxFormProviders`](#api-form-providers) for supplying validator, async validator, and normalizer functions. |
| **name** | Optional name for the form. |
| **debug** | Logs all form actions and state changes if true. |

#### Example

```typescript
const formOptions = {
  reducers: {
    customReset: (formReducers, state) => ({ ...state, reset: true }),
  },
  sources: [externalActions$],
  providers: rxProviders, // See RxFormProviders below
  name: "profileForm",
  debug: true
};

```

### `RxFormProviders` <a name="api-form-providers"></a>

Provides reusable validators, async validators, and normalizer functions for form controls.
**Keys must match the names declared in controls created with control, group, or array.**

| Key                 | Description |
|--------------------|-------------|
| **normalizers**     | Dictionary of functions that transform input values before storing them in state.|
| **validators**      | Dictionary of synchronous validation functions to enforce rules on control values.|
| **asyncValidators** | Dictionary of asynchronous validation functions. Each must be an **observable operator function** that returns an `Observable<FormErrors>` object. |


#### Example

```typescript

const rxProviders = {
  normalizers: {
    trim: (value) => value.trim(),
    numbersOnly: (value) => value.replace(/\D/g, "")
  },
  validators: {
    required: (value) => !!value,
    email: (value) => /\S+@\S+\.\S+/.test(value)
  },
  asyncValidators: {
    uniqueUsername: (control$) =>
      control$.pipe(
        mergeMap(({ value }) =>
          from(nameService.validateName(value)).pipe(
            map((exists) => ({ uniqueUsername: exists }))
          )
        )
      )
  }
};

```



## `RxFormActions` <a name="api-actions"></a>

Actions available to trigger state changes on Form Reactable.

### `updateValues` <a name="api-actions-update-values"></a>

Updates values of a [`FormControl`](#api-form-control). For form group and form arrays, updates will only occur if the specified descendant controls exists. Otherwise it will throw an error.

```typescript
type updateValues = <T>(payload: UpdateValuesPayload<T>) => void;

interface UpdateValuesPayload<T> {
  value: T;
  controlRef: ControlRef;
}

```

### `addControl` <a name="api-actions-add-control"></a>

Adds a control to a form group.

```typescript
type addControl = (payload: AddControlPayload) => void;

interface AddControlPayload {
  config: AbstractControlConfig;
  controlRef: ControlRef;
}

```

### `pushControl` <a name="api-actions-push-control"></a>

Pushes a control to a form array.

```typescript
type pushControl = (payload: PushControlPayload) => void;

interface PushControlPayload {
  config: AbstractControlConfig;
  controlRef: ControlRef;
}

```

### `removeControl` <a name="api-actions-remove-control"></a>

Removes a specified control from the form.

```typescript
type removeControl = (payload: ControlRef) => void;

```

### `markControlAsPristine` <a name="api-actions-mark-as-pristine"></a>

Marks a control and all descendant controls as pristine.

```typescript
type markControlAsPristine = (payload: ControlRef) => void;

```

### `markControlAsTouched` <a name="api-actions-mark-as-touched"></a>

Marks a control and all ancestors as touched. Can set `markAll` to `true` to mark all descendants as touched as well (defaults to `false`).

```typescript
type markControlAsTouched = (payload: MarkTouchedPayload) => void;

interface MarkTouchedPayload {
  controlRef: ControlRef;
  markAll?: boolean;
}

```

### `markControlAsUntouched` <a name="api-actions-mark-as-untouched"></a>

Marks a control and all descendants as untouched. This will recheck ancestor controls and update the touched status.

```typescript
type markControlAsUnTouched = (payload: ControlRef) => void;

```

### `resetControl` <a name="api-actions-resetControl"></a>

Resets a control by removing existing control and rebuilding it with the original configuration.

```typescript
type resetControls = (payload: ControlRef) => void;

```

## Helpers <a name="api-helpers"></a>

### `getArrayItems` <a name="api-get-array-items"></a>

Given a `controlRef` for a form array and a `Form`, returns all the controls for the form array control. If the `controlRef` does not find a form array control an error is throw.

```typescript
type getArrayItems = <T extends BaseForm<unknown> | Form<unknown>>(
  controlRef: ControlRef,
  form: T,
) => T extends BaseForm<unknown> ? BaseControl<unknown>[] : FormControl<unknown>[]
```

### `getAncestorControls` <a name="api-get-ancestor-controls"></a>

Given a `controlRef` a `Form`, returns all the ancestor controls including itself. 

```typescript
type getAncestorControls = <T extends BaseForm<unknown> | Form<unknown>>(
  controlRef: ControlRef,
  form: T,
  excludeSelf = false,
) => (T extends Form<unknown> ? FormControl<unknown> : BaseControl<unknown>)[]
```

### `getDescendantControls` <a name="api-get-descendant-controls"></a>

Given a `controlRef` a `Form`, returns all the descendant controls including itself. 

```typescript
type getDescendantControls = <T extends BaseForm<unknown> | Form<unknown>>(
  controlRef: ControlRef,
  form: T,
  excludeSelf = false,
) => (T extends Form<unknown> ? FormControl<unknown> : BaseControl<unknown>)[]
```

### `getValueFromControlConfig` <a name="api-get-value-from-config"></a>

Reads a [`AbstractControlConfig`](#api-configuration-interfaces) and returns its initial value for the form. 

```typescript
type getValueFromControlConfig = <T>(controlConfig: AbstractControlConfig) => T
```

## Other Interfaces <a name="api-interfaces"></a>

### `Form` <a name="api-form"></a>
Form state. Dictionary of [`FormControl`](#api-form-control)(s) where the key is a period separated representation of the [`ControlRef`](#api-control-ref) tuple.

```typescript
interface Form<T> {
  root?: FormControl<T>;
  [key: string]: FormControl<unknown>;
}

```

### `FormControl` <a name="api-form-control"></a>

```typescript

interface FormControl<T> {
  pristineValue: T;
  controlRef: ControlRef;
  value: T;
  dirty: boolean;
  touched: boolean;
  validatorErrors: FormErrors;
  key: string;
  asyncValidatorErrors: FormErrors;
  asyncValidateInProgress: { [key: string | number]: boolean };
  errors: FormErrors;
  valid: boolean;
  childrenValid: boolean;
  pending?: boolean;
  config: AbstractControlConfig;
}
```
| Property | Description |
| -------- | ----------- |
| pristineValue  | Original value of control. Use to determine if control is dirty. |
| controlRef  | Controls [`ControlRef`](#api-control-ref). |
| value  | Control value. |
| touched  | Touched status of control |
| validatorErrors | [`FormErrors`](#api-form-errors) from validators (non-async) |
| asyncValidatorErrors | [`FormErrors`](#api-form-errors) from async validators |
| errors | [`FormErrors`](#api-form-errors) validatorErrors and asyncValidatorErrors merged. |
| valid | Valid status of control. Also checks descendants.
| childrenValid | Valid status of direct child controls.
| config | Original config for form control |



### `ControlRef` <a name="api-control-ref"></a>

Control Reference represented as a tuple for the [`FormControl`](#api-form-control)

### `FormErrors` <a name="api-form-errors"></a>

Dictionary of errors for the control.

```typescript
interface FormErrors {
  [key: string]: boolean;
}
```

### `ValidatorFn` <a name="api-validator-fn"></a>

Validator function that reads the value of the `FormControl` and returns a `FormErrors` object.

```typescript
type ValidatorFn = (value: unknown) => FormErrors
```

### `ValidatorFnAsync` <a name="api-validator-fn-async"></a>

Validator function takes in an `BaseControl` observable and returns an `Observable<FormErrors>`.

```typescript
type ValidatorAsyncFn = <T>(control$: Observable<BaseControl<T>>) => Observable<FormErrors>;

```


### `FormReducers` <a name="api-form-reducers"></a>

Built in reducers which can be used to update the state of the form tree. Payload and behaviour is the same and described in [`RxActions`](#api-actions);

```typescript

interface FormReducers {
  updateValues: <T>(state: BaseFormState<T>, payload: UpdateValuesPayload<unknown>,
  ) => BaseFormState<T>;
  removeControl: <T>(state: BaseFormState<T>, payload: ControlRef) => BaseFormState<T>;
  pushControl: <T>(state: BaseFormState<T>, payload: PushControlPayload) => BaseFormState<T>;
  addControl: <T>(state: BaseFormState<T>, payload: AddControlPayload) => BaseFormState<T>;
  markControlAsPristine: <T>(state: BaseFormState<T>, payload: ControlRef) => BaseFormState<T>;
  markControlAsTouched: <T>(state: BaseFormState<T>, payload: MarkTouchedPayload) => BaseFormState<T>;
  markControlAsUntouched: <T>(state: BaseFormState<T>, payload: ControlRef,
  ) => BaseFormState<T>;
  resetControl: <T>(state: BaseFormState<T>, payload: ControlRef) => BaseFormState<T>;
}
```
### `CustomReducers` <a name="api-custom-reducers"></a>

```typescript
export type CustomReducerFunc = (
  reducers: FormReducers,
  state: BaseFormState<unknown>,
  action: Action<unknown>,
) => BaseFormState<unknown>;

export type CustomReducer =
  | CustomReducerFunc
  | {
      reducer: CustomReducerFunc;
      effects?: Effect<unknown, unknown>[] | ((payload?: unknown) => ScopedEffects<unknown>);
    };

export type CustomReducers<T> = {
  [key in keyof (T & {
    [key: string]: CustomReducer;
  })]: CustomReducer;
};

```

### `BaseFormState` <a name="api-base-form-state"></a>

Form state before it is fully validated. This is accessible in `CustomReducer`s so developer can read the current state and implement custom form behaviours.

```typescript
interface BaseFormState<T> {
  form: BaseForm<T>;
}

interface BaseForm<T> {
  root?: BaseControl<T>;
  [key: string]: BaseControl<unknown>;
}

```

### `BaseControl` <a name="api-base-control"></a>

`BaseControl` contains some control information before a fully validated `FormControl` is created.

```typescript

interface BaseControl<T> {
  pristineValue: T;
  controlRef: ControlRef;
  value: T;
  dirty: boolean;
  touched: boolean;
  validatorErrors: FormErrors;
  config: AbstractControlConfig;
  key: string;
}
```

### Configuration Interfaces

<a name="api-configuration-interfaces"></a>

```typescript
interface ValidatorConfigs {
  validators?: string[];
  asyncValidators?: string[];
}

export interface FormGroupConfig extends ValidatorConfigs {
  controls: { [key: string]: AbstractControlConfig };
}

export interface FormArrayConfig extends ValidatorConfigs {
  controls: AbstractControlConfig[];
}

export interface FormControlConfig<T> extends ValidatorConfigs {
  initialValue: T;
  normalizers?: string[];
}

export type AbstractControlConfig = (
  | FormControlConfig<unknown>
  | FormArrayConfig
  | FormGroupConfig
) & {
  controls?: AbstractControlConfig[] | { [key: string]: AbstractControlConfig };
};
```